# Advanced Theta* Path Planning with Dynamic Visualization

This project implements an advanced Theta* (Theta Star) path planning algorithm for grid-based navigation in the presence of obstacles. Theta* is an any-angle variant of A* that leverages line-of-sight checks to produce smoother, more direct paths with fewer intermediate nodes and direction changes. The code is designed to be efficient and optimized in several ways and includes dynamic visualization to help users see the path planning process step-by-step.

## Overview

The algorithm constructs a grid graph from a given set of obstacle coordinates, removes nodes that are too close to obstacles, and connects the remaining nodes using an 8-connected motion model (i.e., it allows movement in the four cardinal and four diagonal directions). Theta* search is then applied to compute a path from the start to the goal using a priority queue for efficient node expansion and line-of-sight checking to "shortcut" unnecessary intermediate nodes.

## Features

- **Grid Graph Construction:**
  - Generates a complete grid of nodes based on specified boundaries and resolution.
  - Efficiently removes nodes that are within a specified clearance (robot radius) of obstacles by iterating over a minimal bounding box around each obstacle.
  - Connects the remaining nodes using an 8-connected motion model, which includes both cardinal (cost 1) and diagonal (cost √2) moves.

- **Theta* Search Algorithm:**
  - Uses a priority queue (via Python's `heapq`) to efficiently expand nodes based on a combined cost and heuristic value.
  - Integrates line-of-sight checks between nodes. If the parent of the current node has a clear view to a neighbor, the algorithm “shortcuts” the path, resulting in smoother and more direct paths.
  - Computes key metrics such as execution time, total path length, number of steps taken, and the number of direction changes.

- **Dynamic Visualization:**
  - Dynamically plots each node in the computed path with a pause (0.5 seconds per node) to allow step-by-step observation.
  - After plotting individual nodes, a continuous red line is drawn to represent the final computed path.
  - If the straight-line (direct) connection between the start and goal is unobstructed, a red dashed line is also drawn for visual comparison.

## Optimization Details

- **Precomputation:**  
  The squared radius (for obstacle clearance) is precomputed to avoid redundant square root calculations when checking if a node is too close to an obstacle.

- **Efficient Obstacle Processing:**  
  Instead of checking every grid node against every obstacle, the algorithm iterates only over a bounding box around each obstacle coordinate. This minimizes the number of checks and speeds up the graph construction.

- **Priority Queue with Heapq:**  
  The open set in Theta* is managed using a heap-based priority queue, which ensures that the node with the lowest estimated total cost (current cost + heuristic) is always expanded next.

- **Line-of-Sight Checking:**  
  By using line-of-sight checks, Theta* can bypass unnecessary nodes and directly connect nodes that have a clear path between them. This not only produces a smoother path but also reduces the total number of nodes in the final path, leading to fewer direction changes and a shorter overall distance.

- **Dynamic Visualization Control:**  
  The use of `plt.pause(0.5)` during dynamic visualization allows users to slow down the display of each node, making it easier to observe and debug the planning process.

## Code Explanation

### Graph Construction and Obstacle Handling

- **`build_graph`:**  
  The grid is generated by iterating over the specified x and y ranges. Obstacle nodes are removed by computing a bounding box around each obstacle and checking if each node in that box lies within the clearance radius. This method minimizes the computational load compared to checking every grid node.

- **`motion_mod`:**  
  Returns the list of allowed moves and their costs (1 for cardinal moves and √2 for diagonal moves), ensuring that the graph is connected in all eight directions.

### Theta* Search Algorithm

- **`theta_star_search`:**  
  Uses a priority queue to expand nodes based on the lowest cost-to-go (combining current path cost and a Euclidean distance heuristic).  
  The algorithm uses a line-of-sight check to see if the parent of the current node can directly connect to a neighbor, which helps “shortcut” the path and reduce unnecessary detours.

### Metrics Calculation

- **`calculate_path_length`:**  
  Computes the total Euclidean distance of the computed path.
- **`calculate_direction_changes`:**  
  Counts how many times the movement direction changes along the path, which is an important metric for path smoothness.

### Visualization

- **Dynamic Visualization:**  
  When enabled, each node in the computed path is plotted with a 0.5-second pause to provide a clear step-by-step view.
- **Final Path Drawing:**  
  After dynamically plotting nodes, a continuous red line is drawn to represent the final computed path.
- **Direct Connection Check:**  
  Before drawing a red dashed line directly from start to goal, the algorithm verifies using the `line_of_sight` function that the straight-line connection is not blocked by obstacles.

## Requirements

- Python 3.x
- [NetworkX](https://networkx.org/)
- [Matplotlib](https://matplotlib.org/)

Install the required packages using:

```bash
pip install networkx matplotlib
import math
import time
import heapq
import networkx as nx
import matplotlib.pyplot as plt


class ThetaStarAlgorithm:
    def __init__(self, x_obs, y_obs, resol, radius):
        """
        Initialize the Theta* algorithm with obstacles and parameters.
        - x_obs, y_obs: lists of obstacle coordinates.
        - resol: grid resolution.
        - radius: clearance (robot radius).
        """
        self.resol = resol
        self.radius = radius
        self.graph = nx.Graph()
        self.obstacles = set()
        self.motion = self.motion_mod()
        self.build_graph(x_obs, y_obs)

    def build_graph(self, x_obs, y_obs):
        """
        Build the grid graph:
          - Create nodes for every (x,y) in the grid.
          - Remove nodes within the clearance (radius) of any obstacle.
          - Connect remaining nodes using an 8-connected motion model.
        """
        self.x_min = round(min(x_obs))
        self.y_min = round(min(y_obs))
        self.max_x = round(max(x_obs))
        self.max_y = round(max(y_obs))

        # Create grid nodes.
        nodes = [
            (x, y)
            for x in range(self.x_min, self.max_x + 1)
            for y in range(self.y_min, self.max_y + 1)
        ]
        self.graph.add_nodes_from(nodes)

        # Precompute squared radius.
        r2 = self.radius**2

        # Remove nodes that are within the clearance of an obstacle.
        for ox, oy in zip(x_obs, y_obs):
            min_x_obs = max(self.x_min, int(math.floor(ox - self.radius)))
            max_x_obs = min(self.max_x, int(math.ceil(ox + self.radius)))
            min_y_obs = max(self.y_min, int(math.floor(oy - self.radius)))
            max_y_obs = min(self.max_y, int(math.ceil(oy + self.radius)))
            for x in range(min_x_obs, max_x_obs + 1):
                for y in range(min_y_obs, max_y_obs + 1):
                    if (ox - x) ** 2 + (oy - y) ** 2 <= r2:
                        node = (x, y)
                        if node in self.graph:
                            self.obstacles.add(node)
                            self.graph.remove_node(node)

        # Connect remaining nodes using allowed motions.
        remaining_nodes = list(self.graph.nodes)
        for node in remaining_nodes:
            for dx, dy, cost in self.motion:
                neighbor = (node[0] + dx, node[1] + dy)
                if neighbor in self.graph:
                    self.graph.add_edge(node, neighbor, weight=cost)

    @staticmethod
    def motion_mod():
        """
        Define 8-connected motion vectors (dx, dy) and their cost.
        """
        return [
            (1, 0, 1),
            (0, 1, 1),
            (-1, 0, 1),
            (0, -1, 1),
            (-1, -1, math.sqrt(2)),
            (-1, 1, math.sqrt(2)),
            (1, -1, math.sqrt(2)),
            (1, 1, math.sqrt(2)),
        ]

    def line_of_sight(self, a, b):
        """
        Returns True if there is a clear line-of-sight between nodes a and b.
        Interpolates along the line and ensures each intermediate grid point exists.
        """
        x0, y0 = a
        x1, y1 = b
        dx = x1 - x0
        dy = y1 - y0
        steps = int(max(abs(dx), abs(dy)))
        if steps == 0:
            return True
        for i in range(steps + 1):
            t = i / steps
            x = round(x0 + t * dx)
            y = round(y0 + t * dy)
            if (x, y) not in self.graph:
                return False
        return True

    def calc_heuristic(self, n1, n2):
        """
        Euclidean distance heuristic.
        """
        return math.hypot(n1[0] - n2[0], n1[1] - n2[1])

    def cost(self, a, b):
        """
        Return the cost between adjacent nodes a and b.
        """
        if self.graph.has_edge(a, b):
            return self.graph[a][b]["weight"]
        return math.hypot(a[0] - b[0], a[1] - b[1])

    def theta_star_search(self, start, goal):
        """
        Perform Theta* search from start to goal.
        Returns the final path as a list of nodes.
        """
        open_set = []
        heapq.heappush(open_set, (self.calc_heuristic(start, goal), start))
        came_from = {}
        g = {start: 0}
        came_from[start] = start  # The start's parent is itself.
        closed_set = set()

        while open_set:
            current_f, current = heapq.heappop(open_set)
            if current == goal:
                break
            closed_set.add(current)
            for neighbor in self.graph.neighbors(current):
                if neighbor in closed_set:
                    continue
                # Use line-of-sight: if current is not the start and there is line-of-sight
                # from the parent of current to neighbor, then try that path.
                if current != start and self.line_of_sight(
                    came_from[current], neighbor
                ):
                    tentative_g = g[came_from[current]] + self.cost(
                        came_from[current], neighbor
                    )
                    parent_candidate = came_from[current]
                else:
                    tentative_g = g[current] + self.cost(current, neighbor)
                    parent_candidate = current
                if neighbor not in g or tentative_g < g[neighbor]:
                    g[neighbor] = tentative_g
                    f = tentative_g + self.calc_heuristic(neighbor, goal)
                    came_from[neighbor] = parent_candidate
                    heapq.heappush(open_set, (f, neighbor))

        # If goal was never reached, return empty path.
        if goal not in came_from:
            return []

        # Reconstruct path from goal to start.
        path = [goal]
        current = goal
        while current != start:
            current = came_from[current]
            path.append(current)
        path.reverse()
        return path

    def calculate_path_length(self, path):
        """
        Calculate total Euclidean path length.
        """
        return sum(
            math.hypot(path[i + 1][0] - path[i][0], path[i + 1][1] - path[i][1])
            for i in range(len(path) - 1)
        )

    def calculate_direction_changes(self, path):
        """
        Count number of direction changes in the path.
        """
        changes = 0
        for i in range(2, len(path)):
            prev_dir = (
                path[i - 1][0] - path[i - 2][0],
                path[i - 1][1] - path[i - 2][1],
            )
            curr_dir = (path[i][0] - path[i - 1][0], path[i][1] - path[i - 1][1])
            if prev_dir != curr_dir:
                changes += 1
        return changes

    def planning(self, sx, sy, gx, gy, dynamic_visualization=False):
        """
        Perform Theta* path planning from start (sx, sy) to goal (gx, gy).
        Displays the graph and path, prints metrics (Execution Time, Path Length,
        Steps Taken, Direction Changes) and adds a red dashed line connecting the
        start and goal directly (if unobstructed). When dynamic_visualization is
        True, each point is plotted with a 0.5 second pause, and then a continuous
        red line is drawn connecting the computed path.
        """
        start_time = time.time()
        start = (int(sx), int(sy))
        goal = (int(gx), int(gy))
        if start not in self.graph or goal not in self.graph:
            print("Start or goal node is invalid!")
            return [], []

        # Perform Theta* search.
        path = self.theta_star_search(start, goal)
        if not path:
            print("No path found!")
            plt.title("No Path Found")
            plt.show()
            return [], []

        execution_time = time.time() - start_time
        path_length = self.calculate_path_length(path)
        steps = len(path)
        direction_changes = self.calculate_direction_changes(path)

        print(f"Execution Time: {execution_time:.2f} seconds")
        print(f"Path Length: {path_length:.2f}")
        print(f"Steps Taken: {steps}")
        print(f"Direction Changes: {direction_changes}")

        # Set up the plot.
        fig, ax = plt.subplots(figsize=(10, 10))
        pos = {node: node for node in self.graph.nodes}
        nx.draw(
            self.graph,
            pos,
            node_size=10,
            node_color="yellow",
            edge_color="lightgray",
            alpha=0.6,
            ax=ax,
        )
        if self.obstacles:
            ax.scatter(*zip(*self.obstacles), color="black", s=15, label="Obstacles")
        ax.scatter(start[0], start[1], color="blue", s=50, label="Start")
        ax.scatter(goal[0], goal[1], color="green", s=50, label="Goal")

        # If dynamic visualization is enabled, plot each node with a pause.
        if dynamic_visualization:
            for node in path:
                ax.scatter(node[0], node[1], color="red", s=20)
                plt.pause(0.5)  # 0.5 second pause for each node

        # After plotting the nodes, draw the continuous red line for the computed path.
        rx, ry = zip(*path)
        ax.plot(rx, ry, color="red", linewidth=2, label="Computed Path")

        # Check and add a red dashed line connecting start and goal if the direct connection is clear.
        if self.line_of_sight(start, goal):
            ax.plot(
                [start[0], goal[0]],
                [start[1], goal[1]],
                color="red",
                linewidth=2,
                linestyle="--",
                label="Direct Connection",
            )
        else:
            print(
                "Direct connection from start to goal is blocked by obstacles; not drawn."
            )

        plt.title("Theta* Path Planning")
        plt.legend()
        plt.show()
        return rx, ry


# =============================================================================
# Main Function
# =============================================================================
def main():
    # Define start and goal positions.
    sx, sy = 10.0, 10.0
    gx, gy = 50.0, 50.0
    grid_size = 1.0
    robot_radius = 2.0

    # Define obstacles.
    x_obs, y_obs = [], []
    # Boundary obstacles.
    for i in range(-10, 60):
        x_obs.append(i)
        y_obs.append(-10.0)
    for i in range(-10, 60):
        x_obs.append(60.0)
        y_obs.append(i)
    for i in range(-10, 61):
        x_obs.append(i)
        y_obs.append(60.0)
    for i in range(-10, 61):
        x_obs.append(-10.0)
        y_obs.append(i)
    # Additional obstacles.
    for i in range(0, 40):
        for j in range(10, 20):
            x_obs.append(i)
            y_obs.append(15)
    for i in range(10, 60):
        x_obs.append(40.0)
        y_obs.append(60.0 - i)

    theta_star = ThetaStarAlgorithm(x_obs, y_obs, grid_size, robot_radius)
    rx, ry = theta_star.planning(sx, sy, gx, gy, dynamic_visualization=True)


if __name__ == "__main__":
    main()
